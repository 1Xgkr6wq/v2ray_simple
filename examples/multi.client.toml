# 注意，本作示例文件的dial的目标地址均为 127.0.0.1，是可以直接进行内网测试的; 如果你要用于其它用途，自行修改地址。

[app]
loglevel = 1

# 使用了default_uuid后, 下面其它dial和listen的uuid就可以省略

default_uuid = "a684455c-b14f-11ea-bf0d-42010aaa0003"   


[[listen]]
protocol = "socks5"
host = "127.0.0.1"
port = 10800

[[listen]]

# 这个dokodemo 协议 在这一个示例中, 专门用于监听dns请求, 会通过我们的dial 来转发到 target(1.1.1.1，即cloudflare的dns服务器)
protocol = "dokodemo"
host = "127.0.0.1"
port = 20053
target = "1.1.1.1"
network = "udp"

[[dial]]
tag = "my_vless1"  
protocol = "vlesss"
host = "127.0.0.1"
port = 4433
version = 0    
insecure = true 
utls = true   


[[dial]]
tag = "my_ws1"
protocol = "vlesss"
host = "127.0.0.1"
port = 4434
insecure = true
utls = true
advancedLayer = "ws"
path = "/ohmygod_verysimple_is_very_simple" 

# route就是分流规则，分流规则从上到下匹配，匹配到哪一个就用哪一个. 

[[route]]

# 意思就是所有向CN国家的ip请求的数据通通 通过 my_ws1 这个dial 拨号, 如果你写direct自然就直接直连
# direct并不需要 在dial中实际给出。 "proxy" 代表首个dial，也不需要实际赋值该tag

dialTag = "my_ws1"
country = ["CN"]    


[[route]]
dialTag = "my_vless1"

# 这个最后一个route中，我们只给了tag, 没给其它限定条件，也就是说 如果程序执行到这里, 肯定会匹配到这一条 规则。

# 如果所有route均不匹配，则数据会流向 "proxy" 这个tag 的 dial，如果 没有任何dial具有 "proxy" 这个标签名，则流向第一个dial

# 如果匹配了app.mycountry, 则数据会直接被直连.
# 其它分流匹配示例：
# ip = ["0.0.0.0/8","10.0.0.0/8","fe80::/10","10.0.0.1"]
# domain = ["www.google.com","www.twitter.com"]
# network = ["tcp","udp"]
# inTag = ["tag1","tag2"]
# country = ["CN"]
