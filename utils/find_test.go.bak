package utils_test

import (
	"math/rand"
	"testing"
	"unsafe"

	"github.com/bits-and-blooms/bloom/v3"
)

/*
go1.18
goos: darwin
goarch: arm64
pkg: github.com/hahahrfool/v2ray_simple/utils
BenchmarkSliceFind_10-8         	152484100	         7.447 ns/op
BenchmarkSliceFind_20-8         	100000000	        10.43 ns/op
BenchmarkSliceFind_40-8         	73516086	        16.45 ns/op
BenchmarkSliceFind_80-8         	40491806	        30.28 ns/op
BenchmarkMapFind_10-8           	131343604	         8.255 ns/op
BenchmarkMapFind_20-8           	77772673	        13.84 ns/op
BenchmarkMapFind_40-8           	78834778	        14.75 ns/op
BenchmarkMapFind_80-8           	77047785	        15.59 ns/op
BenchmarkMapFind_800-8          	78424113	        14.88 ns/op
BenchmarkMapFind_8000-8         	78607766	        15.09 ns/op
BenchmarkMapFind_800000-8       	51825218	        21.70 ns/op
BenchmarkMapFind_80000000-8     	21130418	        57.20 ns/op
BenchmarkBloomFind_10-8         	134930332	         8.418 ns/op
BenchmarkBloomFind_20-8         	78121606	        16.51 ns/op
BenchmarkBloomFind_40-8         	73593855	        19.28 ns/op
BenchmarkBloomFind_80-8         	81744565	        14.12 ns/op
BenchmarkBloomFind_800-8        	79790108	        15.19 ns/op
BenchmarkBloomFind_8000-8       	78823557	        15.27 ns/op
BenchmarkBloomFind_800000-8     	53090004	        21.57 ns/op
BenchmarkBloomFind_80000000-8   	21073072	        56.83 ns/op
PASS
ok  	github.com/hahahrfool/v2ray_simple/utils	147.920s


总之数量小于四十时, 直接用数组循环查找是更快的，但是几纳秒的节约没有实际意义;

布隆过滤器没测出比map强在哪里,而且还可能假阳性,暂不考虑; 结论是直接用map匹配即可，无需任何其它机制。

*/

func BenchmarkSliceFind_10(b *testing.B) {
	benchmarkSliceFind(b, 10)
}
func BenchmarkSliceFind_20(b *testing.B) {
	benchmarkSliceFind(b, 20)
}
func BenchmarkSliceFind_40(b *testing.B) {
	benchmarkSliceFind(b, 40)
}
func BenchmarkSliceFind_80(b *testing.B) {
	benchmarkSliceFind(b, 80)
}

func BenchmarkMapFind_10(b *testing.B) {
	benchmarkMapFind(b, 10)
}
func BenchmarkMapFind_20(b *testing.B) {
	benchmarkMapFind(b, 20)
}
func BenchmarkMapFind_40(b *testing.B) {
	benchmarkMapFind(b, 40)
}
func BenchmarkMapFind_80(b *testing.B) {
	benchmarkMapFind(b, 80)
}

func BenchmarkMapFind_800(b *testing.B) {
	benchmarkMapFind(b, 800)
}
func BenchmarkMapFind_8000(b *testing.B) {
	benchmarkMapFind(b, 8000)
}

func BenchmarkMapFind_800000(b *testing.B) {
	benchmarkMapFind(b, 800000)
}
func BenchmarkMapFind_80000000(b *testing.B) {
	benchmarkMapFind(b, 80000000)
}

func benchmarkSliceFind(b *testing.B, size int) {
	b.StopTimer()
	b.ResetTimer()
	s := make([]int, size)
	for i := range s {
		s[i] = rand.Intn(size)
	}

	randBuf := make([]int, b.N)

	for i := 0; i < b.N; i++ {
		randBuf[i] = rand.Intn(size)
	}

	b.StartTimer()

	for i := 0; i < b.N; i++ {
		for j := range s {
			if s[j] == randBuf[i] {
				break
			}
		}
	}
}

func BenchmarkBloomFind_10(b *testing.B) {
	benchmarkMapFind(b, 10)
}

func BenchmarkBloomFind_20(b *testing.B) {
	benchmarkMapFind(b, 20)
}

func BenchmarkBloomFind_40(b *testing.B) {
	benchmarkMapFind(b, 40)
}

func BenchmarkBloomFind_80(b *testing.B) {
	benchmarkMapFind(b, 80)
}

func BenchmarkBloomFind_800(b *testing.B) {
	benchmarkMapFind(b, 800)
}
func BenchmarkBloomFind_8000(b *testing.B) {
	benchmarkMapFind(b, 8000)
}

func BenchmarkBloomFind_800000(b *testing.B) {
	benchmarkMapFind(b, 800000)
}
func BenchmarkBloomFind_80000000(b *testing.B) {
	benchmarkMapFind(b, 80000000)
}

func benchmarkMapFind(b *testing.B, size int) {
	b.StopTimer()
	b.ResetTimer()
	s := make(map[int]bool)
	for i := 0; i < size; i++ {
		s[rand.Intn(size)] = true
	}

	randBuf := make([]int, b.N)

	for i := 0; i < b.N; i++ {
		randBuf[i] = rand.Intn(size)
	}

	b.StartTimer()

	for i := 0; i < b.N; i++ {

		if s[randBuf[i]] {

		}

	}
}

func benchmarkBloomFind(b *testing.B, size uint32) {
	b.StopTimer()
	b.ResetTimer()
	s := bloom.NewWithEstimates(uint(b.N), 0.01)

	var curRand uint32

	for i := 0; i < int(size); i++ {
		curRand = uint32(rand.Intn(int(size)))

		s.Add((*(*[4]byte)(unsafe.Pointer(&curRand)))[:])
	}

	randBuf := make([]int, b.N)

	for i := 0; i < b.N; i++ {
		randBuf[i] = rand.Intn(int(size))
	}

	b.StartTimer()

	for i := 0; i < b.N; i++ {

		if s.Test((*(*[4]byte)(unsafe.Pointer(&randBuf[i])))[:]) {

		}

	}
}
